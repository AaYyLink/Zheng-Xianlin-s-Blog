[TOC]



# 1.  内存和外存的区别

​	存储器是计算机的五大组成部件之一。其中的存储器又分为内存和外存。那么内存和外存和外存有什么区别呢，为什么要将存储器分为内存和外存两部分呢？

​	内存和外存最大的区别就是内存是**易失存储器（Volatile memory）**，如果断电就会导致数据的丢失。而外存是**非易失存储器（Non-volatile memory）**，断电后不会导致数据丢失。主板上的内存直接与CPU相连，CPU可以直接通过地址总线和数据总线访问内存，而CPU不会与外存直接交换数据，想要CPU读取外存的数据必须让外存上的数据先读取到内存中，然后让CPU来间接访问外存的数据。

​	目前的计算机采用内存和外存两种存储器的原因有上面说到的“内存断电丢失数据，外存不会之外”。还有很大的原因就是价格。一个128G的固态硬盘可以卖两三百元，而一个4G的内存却足以卖两三百元了。



# 2.   Linux中的设备驱动

​	**Linux下的设备分类：**一类为**字符(char)设备**，存取的单位为“字符”，例如键盘；另一类为**块设备**(block)，存取的单位为“块”，本节所介绍的硬盘设备就属于块设备。



​	Linux下一切皆文件，设备也是一样，Linux上所有设备的操作都是通过文件接口来实现的。每一个设备都有一个对应的**设备文件**作为它的访问入口，设备文件必须关联对应的**设备驱动程序**，才能使它与对应的设备进行通信。

​	现在有两个问题，能充分理解设备、设备文件和设备驱动程序三者之间的关系，第一个问题就是：如果有现在一台主机上有两个同样的设备，那这两个设备是要关联几个设备文件呢？答案是要关联两个设备文件，即设备和设备文件之间的映射关系为一对一的。第二个问题：那多个同种设备文件和设备驱动程序的映射关系是怎么样的呢？多个同种设备文件和设备驱动程序的映射关系是多对一的。总结一下就是：**每一个设备关联一个设备文件，多个同种设备的设备文件关联一个设备驱动程序**。

​	设备文件只是用户看到的访问入口，所以设备文件的命名自然而然是符合人类的阅读的字符串。而对于计算机而言，计算机更容易阅读的是一串数字，而在Linux中，每一个硬件设备在内核集中都是靠一个设备号来进行标识的，这就方便了硬件和系统的识别。



**设备号的组成：**

**主设备号(major number)**：标识设备类型，用于标明设备所需的驱动程序

**次设备号(minor number)**：标识同种设备类型的不同设备，是特定设备的访问入口。

​	Linux中的/dev目录存储的都是各种各样的设备文件，我们可以使用"ls-l /dev"指令可以查看到该目录下设备文件的设备号：

![图1-1 "ls-l /dev"命令结果](images/1552807411505.png)

注意红色框中的内容，这些就是所谓的设备号，用逗号将主设备号和次设备号隔开，逗号左边为主设备号，逗号右边为次设备号。

可以使用mknod(make block or character special files)指令来创建一个设备文件：

**mknod命令的使用方式**：

mknod  [OPTION]...  NAME  TYPE  [MAJOR  MINOR]
		TYPE：为设备类型，可指定c,b
		-m MODE：创建后的设备文件的访问权限；

**mknod的使用例子**：创建一个新的块设备文件。

1、注意创建的设备文件不能和其他同种设备文件拥有相同的次设备号，否则系统将会出现识别混乱的错误。所以像下图一样查找对应的相同文件。

![图1-2](images/1552809429372.png)

2、创建一个不与当前设备文件设备号冲突的文件。

![图1-3](images/1552809542726.png)

创建完成。



# 3.  硬盘接口类型及其在Linux下的命名

## 3.1  设备的分类

​	我们通过硬盘接口类型来区别不同的硬盘，不同的驱动程序是靠自己的硬盘内部的工作电气特性来实现的。

​	硬盘接口有串口和并口这两类，每一类都包含了多种硬盘接口。

**并口(parallel port)**：数据传输有n根线并行传输

**串口(serial port)**：数据传输仅有一根线按照顺序传输



串口和并口包含的接口的类型及其**IOPS**(Input/Output Operations Per Second，每秒的读写次数)：

**串口**：

​	SATA：6Gbps(6 Gb per second)

​	SAS：6Gbps

​	USB：480MB/s

**并口**：

​	IDE：133MB/s

​	SCSI：640MB/s

> 注意：上述中的B为Byte，b为bit



## 3.2  设备的命名

**在Linux中的磁盘设备文件命名情况如下**：

​	IDE：/dev/hd[a-z]

​	SCSI,SATA,SAS,USB：/dev/sd[a-z]

不同的设备的设备文件名在其后追加的字母不同，一般按磁盘接入计算机的先后顺序附加a到z来命名。



**磁盘分区命名**：磁盘设备在分区后，会为分区创建一个新的设备文件，其名称为在原来的磁盘设备文件名后加上[1-∞]来表示。例如:/dev/hda1,/dev/sda3。





# 4.  机械硬盘的组成

​	学习机械硬盘的构成有利于我们更好的理解Linux的分区过程，因此下面介绍下机械硬盘的组成和运作原理。



## 4.1  机械硬盘的构造

​	机械硬盘主要由盘片、轴、旋转马达、机械臂、磁头五个部分组成（当然还有其他部件，但是这是构成机械硬盘的最关键的部分，明白这五个部件的原理，你就懂了机械硬盘的运作方式）。硬盘的具体构造参考下图。

![图1-4 图片出处：http://blog.sina.com.cn/s/blog_e999bf2d0102w0sb.html](http://www.databack.com.cn/d/file/News/2015-09-18/9e675b9b5597e4a67415f43c1dda2445.jpg)

​	首先盘片固定在旋转轴上，马达会带动旋转轴旋转，机械臂上带有磁头，磁头悬浮在盘面上，用来读写盘片上的数据，机械臂可以伸缩来进行寻道。

​	一个盘片可以划分成N个多个同心圆，称之为磁道。是真正用来存取数据的地方；磁道上存取的数据大小取决于现代技术的工艺。磁道的表示像下图。



![图1-5 磁道](images/1552814114790.png)

​	现在的硬盘都是双面读写的，所谓双面是一个盘片的上下两面均可读写；每个盘面上的相同位置都会有一个相同的编号，所有相同编号的磁道称之为**柱面**。磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的**扇区**。

**扇区的划分**：

​	将每一个磁道按512个字节为单位划分为等分，叫做扇区的划分；一些硬盘的参数列表上会有写明每个磁道的扇区的参数，通常以一个范围来表示，例如：373\~746，这表示最外圈的磁道有746个扇区，最内圈的磁道有373个扇区，可以通过换算磁道的容为(186.5KB\~373KB)



## 4.2 磁盘如何分区

​	根据磁盘的内部结构分析，所有的磁头都是同时运动的。机械臂的运作速度相比于盘面的转速是相当慢的。所以当要读写一个文件数据的时候，如果这个文件数据的内容仅仅分布在一个盘面上的话，操作时间是很久的，所以一般情况下会把文件的内容分布在多个盘面上的同一个磁道上，这样通过多个机械臂上的磁头同时读写数据，速度会大大提升，而磁盘的分区正是如此运作的，磁盘的分区是根据柱面来划分的。另外，由于角速度相同这样的物理原因，外圈的读写速度肯定会比内圈快。

注意：每一个盘面上一个柱面只能属于一个分区，而且由外向内多个柱面组合成一个分区。越靠外的柱面读写速度越快，所以通常会用最外层的多个柱面来作为系统分区。



## 4.3  MBR(Master Boot Record,主引导记录)

​	一个硬盘就是一个存储空间，分区是需要人为来划分的，分区信息是没办法保存在分区内部的某块空间上，那分区信息应该保存在哪？在硬盘上有一个叫做0磁道0扇区是被预留出来的，它不会被划分给任何的分区，这个扇区被称为MBR，严格意义上叫做用来存储MBR的一段空间。

​	0磁道0扇区是专门用来存储MBR的空间，这个扇区的大小为512bytes。

**MBR的三个组成部分：**

- 446bytes：用来存储boot loader，引导加载器；

- 64bytes：用来存储分区表，分区表的内容包括**主要分区(primary partition)**的数量和主要分区的起始和结束位置，每个主要分区需要16bytes，所以采用MBR分区结构的硬盘最多只能有4个主要分区。想得到4个以上的主要分区是不可能做到的，但是可以通过扩展分区()来弥补这个不足，扩展分区也是一种主要分区，但是**扩展分区(extended partition)**可以分为无数个**逻辑分区(logical partition)**，这弥补了主要分区只能分4个的不足。

- 2bytes：前面的信息有效性表示（或者叫做结束标志），用四个16进制数来表示55AA，表示前面510bytes是有效的。

一般情况下会将一块采用MBR分区结构的磁盘划分为3个主分区+1个扩展分区。

  

**注意**：当磁盘容量超过2T时，以MBR的机制是无法识别2T以后的磁盘空间的，此时就需要另一种名叫GPT的机制来分区了。

  

# 5.  磁盘、文件系统的相关概念

**超级块**：保存一个文件系统的大小、可用大小、已用大小。访问分区上的数据需要事先访问超级块。

**元数据**：linux下的元数据指的就是inode(index node)，元数据是用来保存数据的属性的。这些数据有大小、权限、属主属组、时间戳、数据块指针等等。

**文件系统**：文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。

**低级格式化和高级格式化**：**低级格式化**指的是磁盘分区之前对其划分磁道的操作。**高级格式化**指的是分区后对在分区上创建文件系统的操作。

**文件系统的挂载**：要想使用磁盘保存文件，则必须将其创建文件系统后挂载，文件系统的挂载指的就是将额外的分区与根文件系统上的某目录建立关联关系的过程，若挂载所在的目录原先已有文件，则会将其隐藏，显示新挂载的文件系统中的文件。**注意**：尽量只挂载在跟的挂载节点下，这样就不用跨过多个节点后才能访问分区。

**常用的文件系统有**：

- **常用的linux文件系统**：ext2，ext3，ext4，xfs，btrfs，resizerfs，jfs，swap。
- **交换文件系统**：swap
- **网络文件系统**：smbfs(cifs)，nfs
- **集群文件系统**：GFS，OCFS
- **分布式文件系统**：ceph，moosefs，mogilefs，GlusterFS
- **光盘文件系统**：isso9660

根据**是否支持日志**功能可以分为：

- **日志型文件系统**：ext3,ext4,xfs

- **非日志型文件系统**：ext2,vfat

磁盘要经过分区，然后在分区上创建文件系统，之后再在某目录下挂载文件系统后，才能对磁盘分区写入数据。下面的内容会讲解各个步骤所需要使用到的工具及其使用示例。



**buffer**：缓冲，用来缓存写

**cache**：缓存，用来缓存读



# 6.  磁盘分区管理工具



## 6.1  fdisk

**fdisk作用**：`fdisk`命令是用来对磁盘分区的工具，但是其只能做MBR模式的分区。

**fdisk使用方法**：

```bash
fdisk [DEVICE]
	p：显示当前所作的磁盘分区表(也可以是尚未保存的)
	n：新建一个分区
	d：删除一个分区
	t：修改分区的ID
	l：列出所有的分区ID
	w：保存并退出
	q：不保存就退出
```



## 6.2  partx

**partx的作用**：`partx`一般在分区之后执行，是用来让内核重新读取分区表的。

**partx的使用方法**：

```bash
partx -a [DEVICE]
# partx的用法一般都如上所示，除此之外没其他常用的用法了
```

> partprobe [DEVICE]和kpartx -af [DEVICE]也都可以让内核重新读取分区表。
>
> 



## 6.3  分区示例

这里我演示一下如何创建一个分区，该分区后面作为交换分区而使用：

首先，我们插入一个新的硬盘做实验，请不要用原来的系统所在的硬盘上做分区，否则可能会出现错误。

![1555412453043](images/1555412453043.png)

由于是主机中插入的第二块SCSI硬盘，所以该硬盘的命名会是sdb。

```bash
[root@localhost ~]# ls /dev/sdb
/dev/sdb
```

使用fdisk对`/dev/sdb`分区，然后我们先输入n，然后输入p创建主分区，然后指定其其实扇区和结束扇区。

```bash
[root@localhost ~]# fdisk /dev/sdb
```

![1555413414607](images/1555413414607.png)



然后按p查看一下自己所分的扇区

![1555413541037](images/1555413541037.png)

其中显示了分区的起始扇区和结束扇区，以及块数量，还有分区的系统ID。由于我们要把这个分区用作交换分区。因此用t来指定其系统ID。(交换分区的ID号为82，想了解更多的系统ID可以用`l`列出)

![1555413773325](images/1555413773325.png)

然后再用p检查一次配置是否没问题。

![1555413820525](images/1555413820525.png)

可以发现是没有问题的，因此使用w保存退出(千万不要使用q，q是不保存退出)

由于这个新建的磁盘并没有分区处于使用状态，所以可以不适用`partx -a /dev/sdb`来让内核重新读取分区的信息。可以使用`cat /proc/partition`来查看现在内核中的分区信息。

![1555414007676](images/1555414007676.png)

以上内容中有关于sdb1的分区。表示此次分区成功。

请自己接着分区sdb2(5G),sdb3(5G)。

光会分区是没用的，我们必须懂得如何在分区上创建文件系统，在下面的内容中我会讲解。



# 7.  文件系统管理工具



## 7.1  mkfs

**作用**：是用来创建文件系统的格式化操作。

**使用方法**：

```bash
mkfs -t FSTYPE DEVICE
	其中FSTYPE有：ext2,ext3,ext4等
	例如mkfs -t ext4 /dev/sdb2
	
mkfs格式化操作还有另一种写法如下：
mkfs.FSTYPE [DEVICE]

该命令也可以使用-L参数，为磁盘指定卷标：
mkfs -L LABEL DEVICE
例如为/dev/sdb2打上卷标”haha“
mkfs -L haha /dev/sdb2

## 以上的DEVICE和一下所有的DEVICE都是指设备的完整路径。
```



## 7.2  mke2fs

**作用**：这是用于ext系列文件系统格式化的工具。

**使用方法**：

```bash
mke2fs [OPTIONS] DEVICE

OPTIONS:
-t {ext2|ext3|ext4}：指定格式化的文件系统类型
-b {1024|2048|4096}：指定块大小
-L LABEL：指定卷标
-j：创建日志文件系统(ext3)，即-t ext3
-i SIZE:指定没多少个字节创建一个inode，指定的字节数不应该小于块的大小
-N NUM：用来直接指定可用的inode数，其功能其实和-i选项一样
-m REMAINING：用来指定预留空间占个整个分区大小的百分比，默认为5，该预留空间指的是为管理员预留的空间
-O：用来指定创建的文件系统特性(可以使用man ext4等来查询)，其中包括：是否支持日志(has_jornal),是否支持扩展属性(ext_attr)，是否支持一个文件大于2G(large_file)，是否支持一个文件大于2T(huge_file)等。
```





## 7.3  blkid

**作用**：用来查看指定块设备(既可以是分区也可所以是磁盘)的属性信息，其中的属性信息有：设备文件路径，UUID，LABEL(卷标)，TYPE(文件系统类型)。也可以一次性列出所有设备的信息

**使用方法**：

```bash
blkid [OPTIONS] [DEVICE]

OPTIONS：
	-L LABEL：查看LABEL对应的磁盘分区路径，即根据卷标定位设备。
	-U UUID：可以查看到UUID所对应的设备
	
blkid DEVICE：查看特定设备的信息
```



## 7.4  e2label

**作用**：查看和修改ext系列文件系统所在分区的卷标

**使用方法**：

```bash
e2label DEVICE [LABEL]

若不添加LABEL则是查看设备的卷标，若添加之则修改其卷标
```





## 7.5  tune2fs

**作用**：重新设定或查看ext系列文件系统可调整参数的值。

**使用方法**：

```bash
tune2fs [OPTIONS] DEVICE

OPTIONS:
	-l：查看指定文件系统的超级块信息
	-j：升级ext2文件系统为日志型文件系统ext3
	-L LABEL：修改卷标
	-m REMAINNING：
	-O [^]FEATURE:启用或关闭指定特性，特性前加^，表示关闭此特性
	-o [^]mount-options：开启或关闭指定的挂载选项
	-U UUID：修改设备的UUID
#块大小和inode数量是无法修改的
```



> 这里再介绍一个可以查看超级块的方法：dumpe2fs -h DEVICE，其还会显示每个块组的详细信息

------



## 7.6  fsck和e2fsck

**作用**：进程意外终止或系统崩溃等情况导致写入操作非正常终止时，可能会导致文件损坏；此时就需要以下两个工具修复文件系统了，**注意**修复时要卸载掉分区。

**fsck的使用方法**：

```bash
fsck [OPTIONS] DEVICE

OPTIONS:
	-t FSTYPE：用来指明文件系统类型
	-a：自动修复错误，不要轻易使用这个选项
	-r：交互式修复错误
```



**e2fsck的使用方法**：

```bash
e2fsck [OPTIONS] DEVICE
不带参数的情况是会交互的修复

OPTIONS:
	-y：对交互的问题自动回答yes
	-f：强制进行检测，即使硬盘处于clean状态

## 磁盘是否clean可以通过tune2fs来查看，也可以直接执行e2fsck DEVICE，若有显示clean则代表该磁盘处于clean状态。
```



> 注意：千万不要使用自动修复，因为一般情况下这两个工具会把写入的内容删除而达到修复的目的。

根据笔记来看，最大支持单个磁盘容量达到8ZB,1ZB =2^30TB 





## 7.7  文件系统管理示例

接下来将刚刚创建的分区格式化，分别使用`mkfs`,`mke2fs`来格式化成不同的文件系统。

首先将sdb2格式化为ext4文件系统，为其指定卷标为`ILoveLinux`，块大小为2k，并为管理员保留20%的空间，。我们使用`mke2fs`命令来实现。

```bash
mke2fs -L ILoveLinux -t ext4 -m 20 -b 2048 /dev/sdb2
```

我们可以使用`tune2fs -l /dev/sdb2`命令查看该分区的信息：

![1555420541139](images/1555420541139.png)



接下来创建一个xfs类型的文件系统，注意这个文件系统只能用`mkfs`工具创建。

```bash
mkfs -t xfs /dev/sdb3
mkfs.xfs /dev/sdb3
```

检查一下创建的xfs文件系统的相关信息，需要注意的是这里不能使用`dumpefs`和`tune2fs`（它们都只能对ext系列的文件系统使用），需要使用`xfs_admin`命令来查看

首先输入

```bash
xfs_admin -f /dev/sdb3
```

会弹出`xfs_admin> `命令行，输入如下两行即可

```bash
xfs_admin> sb
xfs_admin> print
```

弹出的界面如下所示：(后面还有信息没有显示)

![1555421607640](images/1555421607640.png)



# 8.  挂载文件系统

挂载文件系统可以有开机自动挂载和当前挂载两种方式。当前挂载需要使用`mount`命令，而开机自动挂载需要修改`/etc/fstab`文件。

## 8.1  mount

**作用**：挂载文件系统的工具

**使用方法**：

```bash
mount [OPTIONS] DEVICE

OPTIONS:
	-f FSTYPE：指定文件系统类型
	-r：以只读方式挂载
	-w：读写挂载
	-L LABEL：以卷标方式挂载指定设备
	-U UUID：以UUID的方式挂载指定设备
	-a：自动挂载所有支持自动挂载(/etc/fstab文件中定义的)的设备
	-n：挂载时，不更新/etc/mtab文件
	-B：绑定目录到另一个目录上
	-o：指定挂载选项，可指定多个选项，选项之间以逗号分隔，默认的挂在选项是rw,suid,dev,exec,auto,nouser,async
```

接下来列出常用的挂载选项的功能

| 挂载选项            | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| aync                | 异步IO，数据的写操作先于内存完成，而后再根据某种策略同步至持久设备中，性能好，但不安全 |
| sync                | 同步IO                                                       |
| atime/noatime       | 文件和目录被访问时是否更新最近一次的访问时间戳。例如Web服务器上的文件一秒钟会被访问上百次，这个时候就需要使用到noatime了 |
| auto/noauto         | 设备是否支持mount -a选项的自动挂载                           |
| diratime/nodiratime | m目录访问时，是否更新最近一次的访问时间戳                    |
| dev/nodev           | s是否支持在此设备上使用设备                                  |
| exec/noexec         | s是否允许此设备上执行二进制文件                              |
| suid/nosuid         | s是否支持此设备上的文件使用suid                              |
| remount             | c重新挂载，通常用于不卸载的情况下重新制定挂在选项            |
| ro                  | z以只读方式挂载                                              |
| rw                  | y以读写方式挂载                                              |
| user/nouser         | s是否允许普通用户挂载此设备                                  |
| acl                 | s设备是否支持使用facl(访问文件控制列表)                      |

> 我们可以使用mount，cat /etc/mtab和cat /proc/mounts来查看当前挂载的设备



## 8.2  /etc/fstab

**作用**：修改此文件，可以达到配置设备自动挂载的目的

**使用方法**：

```shell
其每一行都是一个挂载项
每一行的组成部分如下
1. 挂载的设备：可以用设备文件，LABEL，UUID来表示
2. 挂载点，swap类型的设备挂载点为swap
3. 文件系统类型
4. 挂在选项，就是上面表格的选项，选线之间以逗号分隔，也可以使用default来指定为默认的挂在选项
5. 转储频率，可以用三个数字表示，0：从不转储；1：每天转储；2：每隔一天转储一次
6. 自检次序，也用数字表示，有三种自检方式：
	0：表示不自检，一般情况下额外创建的文件系统都无需自动自检
	1：首先自检，一般情况下都是根文件系统要首先自检
	2：次级自检，不同的设备可以使用同一个自检次序(同时自检会导致自检速度变慢)
```



## 8.3  查看文件系统占用等信息

**df**：查看磁盘设备的使用情况

​	-h：以易读的方式显示大小

​	-i：显示inode的使用信息(默认显示的是磁盘空间使用信息)

**du**：查看某目录空间占用情况

​	**-s**：整个目录大小（默认列出目录下各个文件和目录的大小）

​	**-h**：以易读的方式显示大小



**查看已挂载设备的信息**：

1、mount

2、cat /proc/mounts

3、cat /etc/mtab



# 9.  交换分区

交换分区有专门的的管理工具。



## 9.1 mkswap

**作用**：将分区格式化为交换分区

**使用方法**：

```
mkswap [DEVICE]
```



## 9.2  swapon和swapoff

**swapon作用**：是用来启用交换分区的

**使用方法**：

```bash
swapon [DEVICE]
```



**swapoff作用**：用来关闭交换分区的

**使用方法**：

```bash
swapoff [DEVICE]
```



> 我们可以使用free -m查看启用的交换分区的大小

