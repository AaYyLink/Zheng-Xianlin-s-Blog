---
layout: post
#标题配置
title:  HTTP协议基础知识及I/O时间模型讲解
#时间配置
date:   2019-07-24 17:44:00 +0800
#大类配置
categories: Service
#小类配置
tag: Web
---

* content
{:toc}
# 1.  HTTP协议基础知识

## 1.1  http协议的事物过程

由request的发送和response报文的回复组成。

- 客户端的request通过各种各样的user-agent来完成。
- 服务端的response通过httpd（apache）,ngingx等来完成。

## 1.2 request报文和response报文详解

**request报文格式**：

```
<method><URL><VERSION>
HEADERS
<body>
```

其中个字段的意义如下：

| 字段    | 意义                                                         |
| ------- | ------------------------------------------------------------ |
| method  | request所使用的的方法，有GET，HEAD等，后面的表格会有详解     |
| URL     | 统一资源定位符，用来定位资源，具体的格式及其解释后面的表格会有详解 |
| VERSION | 协议的版本                                                   |
| HEADERS | 也就是name:value的键值对，例如报文长度content-length及其对应的值,报文类型content-type及其对应的值 |
| body    | 响应的具体内容，即网页内容，可能会因为method而出现空的情况   |



**response报文格式**：

```shell
<VERSION><STATUS><REASON-PHRASE> 
HEADERS
<body>	
```

其中新出现的字段的意义如下：

| 字段          | 意义                           |
| ------------- | ------------------------------ |
| STATUS        | 状态码，具体下面的表会解释     |
| REASON-PHRASE | 用来解释状态码的核心意义是什么 |

**METHOD的种类及其意义**：

| 种类    | 意义                                         |
| ------- | -------------------------------------------- |
| GET     | 请求获取资源                                 |
| HEAD    | 请求资源但只要其头部                         |
| POST    | 提交表单                                     |
| PUT     | 上传文件                                     |
| DELTE   | 删除文件                                     |
| TRACE   | 跟踪，将一个请求中间经过的代理服务器追踪出来 |
| OPTIONS | 获取一个资源的支持的方法的列表               |

**状态码及其意义**（以下的1xx指的就是1开头后面跟其他两个数）：

| 状态码 | 意义                                     |
| ------ | ---------------------------------------- |
| 1xx    | 信息的响应码                             |
| 2xx    | 成功类响应码，例如200                    |
| 3xx    | 重定向类的响应码,301,302,304（未曾修改） |
| 4xx    | 客户端错误,403,404                       |
| 5xx    | 服务器端错误,502                         |

> 《http权威指南》对于每一种响应码都有详细的讲解。有需要的话，可以当做工作书或字典

**URL的格式**：shceme://username:password@host:port/path;params?query#frag

|          | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| scheme   | 协议，例如http,ftp                                           |
| username | 用户名                                                       |
| password | 密码                                                         |
| host     | 主机地址                                                     |
| port     | 端口号                                                       |
| path     | 资源路径，在URL中成为Location。其与本地文件系统路径相映射，例如：apache中的DocumentRoot。 |
| params   | 对于动态格式的资源需要提供的参数，以便返回用户需要的资源。一般格式为key=value&key=value |
| query    | 需要动用后端数据时（一般就是数据库），一般就是传递给脚本的select语句,field=value |
| frag     | 用来锚定一个网页中的某一个位置用的，例如本篇博客左侧的菜单栏 |

## 1.3 http协议的认证方法

- 基于ip认证
- 基于用户认证：basic/digest（digest不一定被所有的浏览器支持）

> 其实一般情况下都是用表单认证的，也就是调用后端的程序来进行认证的。

# 2.  I/O模型

现在的程序一般都会讲究模块化开发（函数分开来写），也就是说一般情况下一个文件只会写个别函数。一般情况下，一个主程序的执行过程会调用多个函数，每个函数的调用都会打开一个新的上下文，而这些过程背后就有各种各样的I/O在进行着。



## 2.1 I/O模型的类型

关注消息通知机制而言，可以分为**同步I/O**和**异步I/O**:

- **同步I/O**：等待对方返回消息。
- **异步I/O**：不等待对方返回消息，被调用者通过状态、通知或回调机制通知调用者被调用者的运行状态。即调用者不等待函数返回继续执行，一般情况需要调用的函数发送结束信号，回收函数所使用的资源。

关注调用者在等待结果返回之前所处的状态而言，可以分为**阻塞I/O**和**非阻塞I/O**：

- **阻塞I/O**：blocking,调用结果返回之前，调用者被挂起,例如top中的sleeping状态
- **非阻塞I/O**：nonblocking，调用结果返回之前，调用者不会被挂起



然而一般情况下都会将以上两者结合起来描述I/O模型的状态：**同步阻塞**（睡眠）、**同步非阻塞**（忙等），**异步非阻塞**（留给被调用者一个回调接口）三种状态。



## 2.2 服务器并发编程模型的IO类型

服务器并发编程模型的I/O类型有以下几种：阻塞型、非阻塞型、复用型、信号驱动型、异步型

首先需要知道：

一次文件I/O请求，都会有两阶段组成：

1. 等待数据，即数据从磁盘到内核内存；
2. 复制数据，即数据从内核内存到进程内存；

> 注：第一步的占用的时间会比第二步多出很多（仔细想想磁盘的读写速率和内存读写速率的差距）



服务器并发编程模型的I/O类型及其行为：

| 类型       | 行为                                                         |
| ---------- | ------------------------------------------------------------ |
| 阻塞型     | 调用者第一步和第二都是睡眠的                                 |
| 非阻塞型   | 第一步是同步非阻塞，第二部还是同步阻塞（第二步仍然是睡眠的） |
| 复用型     | 一个调用者不只有一路I/O时，不能将其阻塞在一路I/O上，而是阻塞在一个特殊的I/O管理组件（称作I/O复用器）上，可以理解为阻塞在多路I/O上。 |
| 信号驱动型 | 第一段并不阻塞（异步非阻塞状态），第二段依旧是阻塞的；       |
| 异步       | 第一步和第二步都有内核全权完成，都不会被阻塞，是响应能力最强的模型 |

![服务器并发编程模型的I/O类型](https://raw.githubusercontent.com/AaYyLink/image/master/1563961267463.png)

其中复用型I/O使用的I/O管理组件常见的有以下两种：

```shell
select()：帮助一个进程最多监控1024路I/O，httpd中prefork所使用的I/O复用器，也就是说该并发响应模型的每个端口最大并发响应1024个请求。但是一般情况下最大 1024个请求效率已经是最高的了。
poll()：无数量限制
```

信号驱动型I/O常见的API有以下三种：

```shell
epoll（Linux）：libevent（提供了强大的网络IO库）可以使用yum info libevent查看相关信息。
Kqueue(BSD)
/dev/poll（设备文件），Solaris
```

