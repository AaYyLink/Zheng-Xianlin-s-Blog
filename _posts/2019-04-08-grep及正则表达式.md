[TOC]

# 0.  引入

grep是文本三剑客之一，是一个文本过滤工具。grep通过所跟的字符串可以将筛选出用户想要的信息。例如运维人员要查看某个服务是否开启的时候，使用`ss -tunlp`显示出的信息机器的多，一行一行的找是非常浪费时间的。为了节省时间，就可以使用命令行`ss -tunlp | grep ssh`这样，通过管道符来筛选出开启的服务。不仅如此，grep还内嵌了正则表达式引擎，文本过滤功能极其强大。



# 1.  grep的作用及模式概念

**作用**：文本搜索工具，根据用户指定的“模式”对目标文本逐行进行匹配检查；打印匹配到的行。

**模式**：由正则表达式字符及文字字符所编写的过滤条件。



# 2.  grep与正则表达式分类的关系

​    正则表达式分为基本正则表达式和扩展正则表达式，当grep使用不同的参数时，可以选定使用的是哪种正则表达式。
​    

正则表达式类型与grep的对应关系：

| 正则表达式       | 对应的grep                                  |
| ---------------- | ------------------------------------------- |
| 基本正则表达式   | grep -G，是grep的默认参数                   |
| 扩展正则表达式   | grep -E,或者使用egrep指令                   |
| 不使用正则表达式 | grep -F,或者使用是fgrep指令，执行的速度最快 |



# 3.  grep的选项及语法

语法：grep [OPTIONS] PATTERN [FILE...]

选项及其意义：

| 选项    | 意义                                                         |
| ------- | ------------------------------------------------------------ |
| --color | 高亮显示匹配到的字符串                                       |
| -v      | 显示不能被pattern匹配到的行（即没匹配到的行）                |
| -i      | 忽略字符大小写                                               |
| -o      | 仅显示匹配到的字符串                                         |
| -q      | 静默模式，不输出任何信息，该选项常用于为写脚本文件提供返回值 |
| -A #    | 多显示匹配到的行的后#行                                      |
| -B #    | 多显示匹配到的行的前#行                                      |
| -C #    | 多显示匹配到的行的前后#行                                    |
| -E      | 使用ERE，支持使用扩展的正则表达式                            |
| -F      | 不支持正则表达式                                             |



# 4.  grep的基本正则表达式

要用好grep的过滤功能就必须学好正则表达式的使用，接下来介绍的就是基本正则表达式的使用。

## 4.1  字符匹配

- 概念：字符匹配在正则表达式匹配某一个字符。例如[a]就可以匹配中文本“abc”。加上后面介绍的次数匹配可以匹配指定数量的某个字符。
- 字符匹配符号及其意义：

```
    . ：表示匹配任意的字符
    [] ：表示匹配方括号中的一个字符
    [^] ：表示匹配除了了方括号以内的其他所有字符

 [:alnum:]  ：表示匹配所有的字母和数字[:alpha:]  ：表示匹配所有的字母
        [:digit:]  ：表示匹配所有的数字
        [:lower:]  ：表示匹配所有的小写字母
        [:punct:]  ：表示匹配所有的标点符号
        [:space:]  ：表示匹配所有的空白字符(制表符、空格符等)
        [:upper:]  ：表示匹配所有的大写字母
```

## 4.2  次数匹配

- 概念：用于在要指定次数的字符后面，用于指定前面的字符要出现的次数。
      \*：匹配前面的字符任意次
          例如：grep "x\*y"，可以匹配：'abxy'、'xay'、'xxy'、'y'；不可以匹配'x'

> 注意：默认情况下，正则表达式是工作在贪婪模式下，能匹配多少就匹配多少。

```
.*：表示匹配任意长度的任意字符
\?：表示匹配其前面的字符0或1次，即前面的可有可无。
\+：表示匹配前面的字符1次或多次，即至少一次
\{m\}：表示精确匹配前面的字符m次
\{m,n\}：表示匹配前面的字符至少m次，至多n次
\{0,n\}：表示匹配前面的字符至多n次
\{m,\}：表示匹配前面的字符至少m次
```

## 4.3  位置锚定

- 概念：对特定位置进行定位

  ```
  ^：行首锚定，用于匹配某行的最左侧，即让模式只能匹配行首
  $：行尾锚定，用于匹配某行的最右侧，即让模式只能匹配行尾
  ^PATTERN$：表示匹配一整行的模式
      ^$：匹配空行，表示没有任何字符
      ^[[:space:]]*$：匹配行有多个空格符，或者为空
  \<或\b：词首锚定，用于匹配单词的左侧，即让模式只能匹配词首
  \>或\b：词尾锚定，用于匹配单词的右侧，即让模式只能匹配词尾
  \<PATTERN\>：用来匹配整个单词
  ```

  

> 正则表达式匹配的单词指的是由非特殊字符组成的连续字符（字符串）。不同于现实生活中的单词，正则表达式匹配的单词可以没有意义。

## 4.4  分组

概念：分组是指将一个或多个字符捆绑在一起，当作一个整体进行处理，其符号为：\\(\\)
如：\\(xy\\)*ab 表示xy这个整体可以出现任意次。

注意：

```
1、括号中的模式匹配到的内容会被正则表达式引擎记录于内部变量中。这些变量命名的
      方式为：\1,\2,\3,... ...
      \1：从左侧起，第一号左括号以及与之匹配的右括号之间的模式所匹配到的字符；
      
      如：\(ab\+\(xy\)*\)中，\1表示：ab\+\(xy\)*;\2表示：xy

2、后向引用：引用前面的分组括号中的模式所匹配的字符，而非模式本身。
```



> 需要注意的是，正则表达式引擎会在每行开始都重新将分组匹配到的内容记录到内部变量中，所以每行的后向引用的值都可能不同。而且，\1,\2,\3 ... ... 这些内部变量在正则表达式之外引用。



## 4.5  示例

```bash
#显示 /proc/meminfo 文件以大小或小写S开头的行
grep -i '^s' /proc/meminfo 

# 显示 /etc/passwd 文件中其默认 shell 为非 /sbin/nologin 的用户：
grep -v '/sbin/nologin$' /etc/passwd | cut -d ":" -f1

# 显示 /etc/passwd 文件中其默认 shell 为 /bin/bash 的用户；进一步：仅显示上述结果中其ID最大的用户：
sort -r -t ":" -k3 -n /etc/passwd | grep '/bin/bash$' | head -n1 | cut -d ":" -f1

# 找出 /etc/passwd 文件中的一位数或两位数：
grep '\b[[:digit:]]\{1,2\}\b' /etc/passwd

# 显示 /boot/grub/grub.conf 中以至少一个空白字符开头的行(我的CentOS7中并没有对应的文件)
grep "^[[:space:]]\+" /boot/grub/grub.conf

# 显示 /etc/fstab 文件中，以 '#' 开头，后面跟至少一个空白字符，而后又有至少一个非空白字符的行
grep "^#[[:space:]]\+[^[:space:]]\+" /etc/fstab 

# 找出 netstat -tan 命令执行结果中以'LISTEN'结尾的行
netstat -tan | grep 'LISTEN[[:space:]]*$'

# 添加用户 bash，testbash，basher，nologin（SHELL为/sbin/nologin），而找出当前系统上用户名和默认 shell 相同的用户。
grep '^\(\<.*\>\).*\1$' /etc/passwd

# 显示/etc/passwd文件中不以/bin/bash结尾的行
grep -v "/bin/bash$" /etc/passwd 

#显示/etc/passwd文件中，包含二位或三位数字的行
grep "\<[[:digit:]]\{2,3\}\>" /etc/passwd 
```

# 5.  grep的扩展正则表达式

- 介绍：扩展正表达式可以更好的筛选字符串，但是处理速度比基本正则表达式慢。扩展正则表达式的锚定符号和普通的正则表达式相同，以下不再重复说明。

- 扩展正则表达式的使用语法：

  grep -E 'PATTERN' FILE...

  egrep 'PATTERN' FILE...

  

## 5.1  字符匹配

```
[]：匹配指定范围内的任意单个字符
[^]：匹配指定范围外的任意单个字符
```


基本和基本正则表达式相同

## 5.2  次数匹配

```
*：任意次
?: 0次或1次
+：至少一次
{m}：精确匹配m次
{m,n}：至少m次，至多n次
{m,}：至少m次
{0,n}：至多n次
```


扩展正则表达式大部分的次数匹配比基本的正则表达式少了'\'符号，即不需要转义。

## 5.2  分组

()：用括号括起来表示要引用的内容，不需要转义。

后向引用：\1,\2,\3

## 5.4  或者

```
(x|y)：x或者y
(Y|y)es：Yes或者yes
```



## 5.5  示例

```bash
# 显示当前系统上root、fedora或user1用户的默认shell：
grep -E "^(root|user1|fedora):" /etc/passwd | cut -d ":" -f1,7

# 找出 /etc/rc.d/init.d/functions 文件中某单词后跟一组小括号“()”行：
grep -E '\<[[:alpha:]]+\>\(\)' /etc/rc.d/init.d/functions 

# 使用 echo 命令输出一个路径，而后使用egrep取出其基名：
echo "/etc/shadow/zxl" | egrep -o "[^/]+/?$"

# 找出ifconfig命令结果中的1-255之间的数字：
ifconfig | grep -E '\b([1-9]|[1-9][0-9]|1[0-9][0-9]|2[1-4][0-9]|25[0-5])\b' -o

# 找出ifconfig命令结果中的IP地址
ifconfig | grep -E '(\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[1-4][0-9]|25[0-5])\b.){3}\b([1-9]|[1-9][0-9]|1[0-9][0-9]|2[1-4][0-9]|25[0-5])\b' -o

# 用三种方法实现/proc/meminfo文件中以大写S或小写s开头的行
grep -E '^(S|s)' /proc/meminfo
grep -E '^[Ss]' /proc/meminfo
grep -i '^s' /proc/meminfo
```

