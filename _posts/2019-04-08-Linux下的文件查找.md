[TOC]

# 0  引入

Linux下文件的搜索需要用到locate和find，以下会给出这两个命令的介绍和用法。



# 1  locate命令的介绍和使用

**介绍：**locate 属于非实时查找，它是依赖于事先构建好的索引数据库进行搜索的。索引数据库的更新会在系统空闲时自动进行，手动更新则需要使用updatedb命令来更新的，注意：手动更新需要遍历整个根文件系统，极其消耗资源。

**特点**：查找速度快，非精确查找，模糊查找。

**使用方式**：locate KEYWORD

**常用选项及其意义**：

| 选项 | 衔接的参数及其意义                                           |
| ---- | ------------------------------------------------------------ |
| -b   | 不衔接参数，只匹配路径的基名                                 |
| -c   | 不衔接参数，统计文件数                                       |
| -r   | 不衔接参数，将原来的关键字查找转换成正则表达式查找。注意：该选项匹配的是整个路径而非路径的基名。 |



locate的用法非常简单，但它只是在索引数据库中查找文件，假如没有及时更新索引数据库就会造成系统中已有的文件却搜索不到的结果。而且其模糊查找的特点会带来很多你不想看到的结果。



# 2  find命令的介绍和使用

**介绍**：find属于实时查找工具，通过遍历指定路径下的文件系统完成文件查找，并不需要像locate那样建立数据库。find指令还提供了很多好用的选项及参数，可以更精确的匹配到你想要的结果。

**特点**：精确查找，精准查找，速度慢

**使用方法**：find [option]... [查找路径] [查找条件] [处理动作]

**查找路径**：默认为当前目录

**查找条件**：默认为指定路径下的所有文件

**处理动作**：默认为显示至屏幕



## 2.1  find查找条件

**根据文件名查找：**

-name FILENAME：支持使用globbing字符

​            *：任意长度的任意字符

​            ?：表示任意单个字符

​            []：匹配指定范围的任意单个字符

​           [^]：匹配指定范围外的任意单个字符

-iname FILENAME：查找时忽略字符大小写

**根据文件从属关系查找：**

-user USERNAME：根据文件的属主查找

-group GRPNAME：根据文件的属组查找

-uid UID：根据文件属主的UID进行查找

-gid GID：根据文件的属组GID查找

-nouser：查找没有属主的文件

-nogroup：查找没有属组的文件

-regex REGEX：匹配的是整个路径如：find / -regex ".*/passwd"

**深度限定查找：**

-maxdepth LEVELS：进入命令行参数指定的目录下层目录时，最深不超过LEVELS(一个非负整数)。意味着只在命令行参数指定的目录中执行测试和动作。

-mindepth LEVELS：不在LEVELS(一个非负整数)层之内执行任何测试和动作。'-mindepth 1'意味着处理所有的文件, 除了命令行参数指定的目录中的文件

**组合条件查找：**

与：-a，需要同时满足前后两个条件

或：-o，只需满足前后两个条件中的一个即可

非：-not，！，都代表取反

**举例：**

​        -not A -a -not B = -not \( A -o B \)：不是A也不是B

​        -not A -o -not B = -not \( A -a B \)：不是A或者不是B

​        -not \\( -iname "\*r\*" -o -user testuser \\)

**注意：**括号需要转义，并且括号与字符间必须有空格

**根据文件类型查找：**

-type TYPE：根据文件类型查找

​        f：普通文件

​        d：目录文件

​        l：符号链接

​        b：块设备

​        c：字符设备

​        s：套接字文件

​        p：命名管道

**根据文件大小：**

-size [+|-]#UNIT：'#'表示数字，UINIT为单位，常用的单位有k,M,G

​        \#UNIT：#-1<x<=#

​        +#UNIT：x>#

​        -#UNIT：x<=#-1

举例：2G表示1G<x<=2G

​           +2G表示x>2G

​           -2G表示x<=1G

**按时间戳查找：**

以"天"为单位：

​        -atime [+|-]#：

​              +#：x>=#+1

​              \#：#<=x<#+1

​              -#：#<x

\#中表示的天数为离当前所有的天数，例如离现在0-24小时的可以用“-1”来表示。-mtime，-ctime也是同样的用法

以"分钟"为单位：

​        -amin

​        -mmin

​        -cmin

**根据权限查找：**

-perm [+|-]MODE

​        MODE：与MODE精确匹配

​                find ./ -perm 644

​        +MODE：任何一类用户的权限只要能包含对其指定的任何一位权限即可；以属主为例

​                find ./ -perm +222 表示任何一类用户的权限中包含写权限就可以匹配到

​                find ./ -perm +621 表示属主有读或者写，或者属组有写，或者其他有执行权限都可以

​        -MODE：任何一类用户的权限都必须包含指定的权限。

​                find ./ -perm -222 表示任何一个用户都应该包含有写权限

​                find ./ -perm  -666 表示任何一个用户都应包含读和写权限。

## 2.2  处理动作

-print：默认处理动作，显示，打印到屏幕上

-ls：类似于ls -l

-delete：删除查找到的文件（比较危险的操作，建议不要使用）

fls FILEPATH：查找到所有文件的长格式信息保存至指定文件中

-ok COMMAND {} \\;：对查找到的每个文件执行由COMMAND指定的命令；对于每个文件执行命令之前，都会交互式要                                                  求用户确认；其中{}表示前面查找到的所有内容的引用;

## 2.3  使用find需要注意的点

- find /tmp -nouser -o nogroup -ls 和 find /tmp \( -nouser -o -nogroup \) -ls表示的意义是不一样的，前一个命令中的ls表示仅将-o右侧的-nogroup显示出来，第二个才是真正表示没有属主或没有属组的文件同时显示。
- find是一次性查找符合条件的所有文件，并一同传递给-exec或-ok后面指定的命令；但有些命令不能接收过长的参数；此时使用另一种方式可规避此问题:：find | xargs COMMAND

> 关于xargs的使用可以参考这篇博客https://blog.csdn.net/u012379954/article/details/88598192



## 2.4  案例

```bash
# 查找/var目录属主为root且属组为mail的所有文件
]# find /var -user root -group mail


# 查找/usr目录下不属于root、bin或hadoop的所用文件
]# find /usr -not \( -user root -o -user bin -o -user hadoop \)


# 查找/etc目录下最近一周内其内容修改过的，且不属于root且不属于hadoop的文件
]# find /etc -mtime -7 -not -user root -not -user hadoop
   

# 查找当前系统上没有属主或属组，且最近1个月内曾经被访问过的文件
]# find /etc \( -nouser -o -nogroup \) -a -atime -30


# 查找/etc目录下大于1M且类型为普通文件的所有文件
]# find /etc/ -size +1M -type f


# 查找/etc目录所有用户都没有写权限的文件
]# find /etc -not -perm +222


# 查找/etc目录下至少有一类用户没有写权限
]# find /etc -not -perm -222 


# 查找/etc/init.d/目录下，所有用户都有执行权限且其他用户有写权限的文件
]# find /etc/init.d/ -perm -113
```

