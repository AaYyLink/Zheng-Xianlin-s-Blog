[TOC]

<span id="des"></span>

# 0.  引入

一个运维工程师必须懂得如何管理进程和作业，这样才能让服务器的运行更稳定，效率最大化。本篇博客就会介绍进程和作业的相关概念以及如何在Linux下管理进程和作业。



# 1.  进程的相关概念

## 1.1  进程是什么？

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。进程和程序的关系严谨的说就是：程序是指令、数据及其组织形式的描述，进程是程序的实体。通俗的来说就是：一个程序若没有运行则仅仅是一个程序，而运行程序则会产生新的进程。



## 1.2  进程如何创建？

每次运行一个程序或者命令就会触发产生一个新的进程。



## 1.3  关于进程需要了解的概念

**PID**：在Linux系统当中，每一个进程都有自己的PID，PID是用来标识进程的。

**task struct**：Linux下，用来描述进程的数据结构，而该数据结构就是所谓的进程控制块。task struct会保存进程的相关数据，例如：进程状态，进程调度信息，标识符等。

**task list**：Linux下，由多个任务的task struct组建的链表。

**进程之间的关系**：所有进程间呈现树状结构，以下暂且称为进程树。每一个进程都是从根衍生而出的子进程。新的进程由旧的进程创建而产生。新的进程相对于旧的创建自己的进程称为子进程，旧的进程相对于自己创造产生的新进程称为父进程。

**子进程**：由其它父进程创建的进程，相对于创造自己的父进程，被称为子进程。

**父进程**：创建了多个子进程的进程，相对于自己创造的子进程，被称为父进程。

**CoW(Copy-on-Write)**：写时复制更新是Linux创建子进程时所使用的机制。在Linux上创建子进程时，子进程是不会先分配空间的，而是共用父进程的数据空间，当子进程要修改数据时，则会复制父进程的数据并使用新的一片空间粘贴，再在其上修改。

**僵尸进程**：一般而言，子进程完成任务后，父进程会负责回收子进程使用的资源。僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。

**守护进程**：在后台运行，并与终端无关的进程。

**前台进程**：用终端启动并于终端相关的进程。

**进程的分类**：分为CPU密集型和IO密集型

​	**CPU-Bound**：CPU密集型；一般为非交互式进程

​	**IO-Bound**：IO密集型，一般为交互式进程



上面提到，进程树是从根部衍生的，那么，进程树的根想必没有父进程。那这个根又是什么呢？

```
这个根是init进程，也是操作系统启动时创建的第一个进程。init进程是由内核创建的进程，是没有父进程的进程。init创建后，才会创建用户空间，而用户空间是由init管理的。根下的各个子进程也都是init创建的。
```



> Linux下父进程创建子进程的函数有：fork(),clone()



接下来介绍进程的优先级，因此在此介绍下CPU的调度是什么。

```
每一个进程都需要占据一个CPU的核心，而操作系统中运行的进程往往比CPU的核心数量多的多。Linux操作系统会将CPU的使用时间分割成时间片段，在每个时间片段上运行不同的进程，来达到在操作系统上运行多个进程的目的。而每次的切换CPU处理的进程的过程叫做进程调度。（由于CPU的运算速度很快，对于人来说是察觉不到进程调度的，所以会给人一种一个核心可以运行多个进程的感觉）
```



## 1.4  进程被内核调度过程中的状态

1. **运行态**(running)：表示进程正在使用CPU
2. **就绪态**(ready)：表示进程已经被加入运行队列，等待处理器的使用权
3. **睡眠态**(sleeping)：处于申请资源的状态。并分为可中断睡眠和不可终端睡眠
   1. 可中断睡眠(interruptable sleeping)：表示当前申请资源的状态可被中断，从而直接进入就绪状态。
   2. 不可中断睡眠(uninterruptable sleeping)：表示当前申请资源的状态不可被中断。
4. **僵死态**(zombie)：表示子进程完成后，父进程没有回收子进程，释放子进程占用的资源
5. **停止态**(stopped)：表示该进程不可被调度并运行	



这里放上一张Linux下的进程转换图

![进程转换图](../归档/images/进程转换图.jpg)

上图来源于http://blog.163.com/login.do?err=403

## 1.5  进程的优先级

每个进程都有自己的进程优先级，这些优先级决定了CPU是否优先调度其来运行。

进程优先级由0\~139的数字表示，其中：

0\~99是**实时(动态)优先级**，数字越大表示优先级越高，无法手动修改

100\~139是**静态优先级**，数字越小表示优先级越高，可以用Nice值间接修改



一般情况下，进程管理命令显示出的PRI范围为0\~39(对应静态优先级的100\~139)和表示实时优先级的"rt"。

## 1.6  Nice值

范围是-20\~19：普通用户只能将其变大而不能变小，一个进程的Nice值默认为0

可以用其间接修改进程的静态优先级，-20\~19对应静态优先级的100\~139。



Linux中的两种队列：一种是运行队列，一个是过期队列。每个队列中都有140个优先级，运行队列中的进程运行完后，再将其中的进程与过期队列中的进程相互交换。



> nice值的查看可以使用ps -l



# 2.  进程内存的相关概念

- **Page Frame**：页框，用于存储数据的，使得进程保存在物理内存上的位置不成线性。
- **MMU**(Memory Management Unit)：当一个进程访问逻辑地址空间上的数据时，由MMU转换成物理地址。
- **缺页异常**：访问在交换内存中的数据时，会发生缺页异常。
- **常驻内存集**：只能保存在内存中的数据
- **虚拟内存集**：指既可以保存在虚拟内存中，也可以保存在内存中的数据
- **IPC**(Inter Process Communication，进程间通信)的方式：
- **同一主机上的进程间通信的方式**：
  - signal：信号指令
  - shm(shared memory)：共享内存空间。
  - semerpohre：旗帜语
- **不同主机上的进程间通信的方式**：
  - rpc(remote procedure call)：远程过程调用
  - socket：套接字



# 3.  进程的查看及管理命令

Linux系统上的进程查看及管理命令有很多，这里介绍几个常见的，对于常见但不常用的命令不会给出过多的描述。



## 3.1  pstree

```
pstree是用来查看进程树(进程的父子关系)的命令。
注意：pstree不能显示内核进程
```



## 3.2  ps

**作用**：显示ps命令执行时，系统中各进程的状态。

> ps命令是通过/proc(内核中的状态信息)来显示各个进程的信息的。可以使用`ls /proc`看到该目录下有用PID命名的目录。



**使用方法**

```bash
ps [options]

ps的选项有三种类型：
	UNIX类：选项前加'-'
	BSD类：选项前不需要加'-'
	GNU类：长格式，需要在选项前加入两个'-'

ps的常用选项：
	a：显示所有与终端相关的进程
	x：显示所有与终端无关的进程			# ps ax可以显示所有进程
	u：根据进程所属的用户组织显示的信息
	o：自定义要显示的字段列表，以逗号分隔，常用的字段有：pid,ni,pri,psr，pcpu，stat，comm，tty，ppid,rtprio
    -e：显示所有的进程
    -f：显示进程信息的完整格式
    -F：显示进程信息的额外完整格式，但与上面的-f不同
    -H：以树状结构显示进程的相关信息
    
# 显示出的COMMAND带方括号表示是内核进程
# o对应字段的解释可以用man查询得到
```

常用的选项组合有以下几种：

1、**ps aux**

![1554809710048](../归档/images/1554809710048.png)

2、**ps -ef**

![1554809771805](../归档/images/1554809771805.png)

3、**ps -eF**

![1554809913305](../归档/images/1554809913305.png)

4、**ps -eFH**

![1554810109120](../归档/images/1554810109120.png)

5、**ps axo**

![1554810171350](../归档/images/1554810171350.png)



**ps显示的各个字段的意义**：

- **USER**：进程的发起者
- **PRI**：进程的优先级
- **PID**：进程号
- **%MEM**：内存空间的占用率
- **%CPU**：累计使用CPU的时间
- **VSZ**：占用的虚拟内存大小，单位为kb
- **RSS**：常驻内存集大小，单位为kb
- **STAT**：进程状态，有以下几种进程状态。R：running；S：intteruptable sleeping；D：uninterruptable sleeping；T：Stopped；Z：zombie；+：前台进程；l：多线程进程；N：低优先级进程；<：高优先级进程； s：session leader
- **NI**：Nice值
- **TTY**：进程在哪个终端运行
- **START**：创建该进程的时间
- **TIME**：进程累计使用CPU的时间
- **COMMAND**：触发此进程的命令
- **PSR**：该进程在哪个CPU运行，CPU用编号标识



## 3.3  pgrep和pkill

pgrep和pkill是同一个命令组的，因此他们共享大部分的参数。

**pgrep的作用**：过滤进程，得到进程号

**pgrep的使用方法**

```bash
pgrep [options] pattern

options:
	-u uid：衔接的effective user的uid，匹配effective user
	-U uid：衔接的real user的uid，匹配real user
	-t TERMINAL：衔接终端，匹配与指定终端相关的进程
	-l：显示进程名
	-a：显示完整的命令(包括参数)
	-P pid：显示此进程的子进程
```

**pkill的作用**：发送指定的信号给过滤得到的所有进程，使进程中止或重启等；默认的信号为SIGTERM。

**pkill的使用方法**

```bash
pkill [options] pattern
option:
	--signal signal：指定传输的信号
# 以上pgrep大多数的筛选参数都对pkill有用
```



## 3.4  pidof

**作用**：根据进程名取得pid

**使用方法**：

```bash
pidof PROGRAMNAME
```



## 3.5  top

**作用**：top命令类似于Windows的任务管理器，可以以窗口化的形式动态查看各进程的状态。

> 这里穿插一个概念---负载：指的是等待运行的进程队列的长度。

**使用方法**：

```bash
top [options]

options:
	-b：批次显示所有进程
	-n NUMBER：指定NUMBER为显示的批次数量
	-d SECS:指定SECS为top程序刷新的延迟时长
	
top命令执行后弹出的窗口中可以执行内部命令。
以下列除内部命令的使用：
P：让显示的进程以占用的CPU百分比大小排序
M：以占据Memory空间百分比大小排序
T：以CPU累计使用时间进行排序
l：是否显示系统负载行
t：是否显示进程的摘要信息及CPU负载状态
1：数字1，平均或单独的显示CPU的负载状态
m：修改内存相关的状态信息的显示格式
q：退出命令
s：修改刷新的延迟时长
k：终止指定进程
```



下面给top命令执行后的图片。

![1554812396092](../归档/images/1554812396092.png)

图片无法动态显示，事实上，top命令执行后每3秒都会刷新一次。



**top命令信息详解**

接下来参照上图，讲解top命令产生的信息含义：

第一行：该行可以在命令行中使用uptime命令来显示

​	**top -** ：后跟当前的系统时间

​	**up**：后跟系统启动了多长的时间

​	**users**：前跟当前登陆系统的用户数量	

​	**load average**：后跟系统在1,5,15分钟的平均负载，数值越小表示系统越空闲，假若有数值大于1，则需要注意当前系统的负载过高。(越大表示系统中进程的等待队列越长)



第二行：

​	**total** ：前跟当前系统的进程总数

​	**running**：前跟当前系统中处于running状态的进程总数

​	**sleeping**：前跟当前系统中处于sleeping状态的进程总数

​	**stopped**：前跟当前系统中处于stopped状态的进程总数

​	**zombie**：前跟当前系统中处于zombie状态的进程总数



第三行：该行显示的是CPU的整体负载，按下数字1键可以切换成显示各个CPU的负载率

​	**us**(user space)：用户运行程序占用的CPU时间百分比

​	**sy**(system space,kernel space)：运行内核占用的CPU时间百分比

​	**ni**(nice)：nice用户进程空间所改变过优先级的进程占用的CPU时间百分比

​	**id**(idle)：空闲的CPU时间百分比

​	**wa**(wait io)：等待I/O所花费的CPU时间百分比

​	**hi**(hardware interrupt)：硬件中断占用的CPU时间百分比

​	**si**(software interrupt)：软件中断占用的CPU时间百分比

​	**st**(stolen)：被虚拟机借用的CPU时间百分比



第四行：物理内存的使用状况

​	**total**：当前系统所有的物理内存空间

​	**free**：当前系统空闲的物理内存空间

​	**used**：当前系统已使用的物理内存空间

​	**buff/cache**：用于缓存和缓冲的物理内存空间

​	

第五行：交换分区的使用情况(除available的各字段解释与上述相同)

​	**avail Mem**：可以使用的交换分区空间



第六行：默认是显示空白的，在top程序中输入命令时，显示输入状态的地方。



第六行之后的内容显示的是各个进程的具体信息。

以下列出各个字段的意义：

​	**PID**：进程ID

​	**USER**：进程的使用者

​	**PR**：Priority，进程的优先级，越小优先级越高

​	**NI**：Nice，Nice值，越小越容易被运行

​	**VIRT**：进程需要的虚拟内存大小，而不是使用的虚拟内存大小

​	**RES**：当前使用的内存大小(不包括swap)

​	**SHR**：进程与其他进程共享的内存大小，进程所占用的物理内存大小=RES-SHR

​	**S**：进程的状态

​	**%CPU**：CPU的使用率

​	**%MEM**：内存的使用率

​	**TIME+**：累计使用CPU的时间



> 以上绝大部分的命令信息详解都可以使用man命令查询



## 3.6  htop

**作用**：htop命令算是top命令的增强版，也是窗口化显示进程信息的。可以更加直观的查看操作系统中的进程状态和各类资源的使用状况。

**使用方法**：

```bash
htop [options]

options:
	-d SECS：指定刷新的延迟为SECS
	-u USER：仅仅显示指定用户的进程
	-s COLUMN：显示的进程以指定的字段进行排序
	
htop和top命令一样可以在程序运行后输入内置命令。按下F1就可以查看Help文档，其中就包含了各个内置命令的意义。
下面列出常用的内置命令：
l：显示选定进程打开的所有文件
t或F5：以层级结构显示各个进程
s：跟踪选定进程发起的系统调用(跟踪后还可以使用AutoScroll(F8)进行自动滚动)
a：将选定的进程绑定至指定的核心(绑定时需要按空格键开启或取消)
F2：设置htop显示的样式(可以添加显示电量)
```

> htop的安装需要借助第三方源，htop有收入于epel源中。





## 3.7  vmstat

> 应聘Linux运维岗位的同学需要认真的记住该命令的字段含义，据说面试经常考这个命令

**作用**：统计虚拟内存的统计数据。也可以动态显示内存、磁盘、网络、cpu等资源的使用情况。

**使用方法**：

```bash
vmstat [options] [delay [count]]

delay：指定刷新的间隔
count：指定刷新的次数

options:
	-s：显示内存统计数据
	-S：衔接单位，如K、M、b，默认单位为k
	-d：列出各个磁盘的读写总量统计表
```



下面给出vmstat的输出：

![1554864771404](../归档/images/1554864771404.png)

参考上图，以下列出各个字段的意义

**procs**：表示与进程相关的信息

​	r：等待在CPU上运行的任务的队列长度，即等待运行的进程的个数

​	b：处于不可中断睡眠状态的进程个数，即IO阻塞队列长度



**memory**：与内存相关的信息

​	swpd：交换内存的使用量

​	free：空闲的物理内存量

​	buffer：用于buffer的内存总量

​	cache：用于cache的内存总量



**swap**：与交换分区相关的信息

​	si：数据进入swap中的速率(kb/s)

​	so：数据离开swap的速率(kb/s)



**io**：与io相关的信息

​	bi：将块设备的数据读入到系统的速率(kb/s)

​	bo：将数据保存至块设备的速率(kb/s)



**system**：显示有关于系统的信息

​	in：中断速率，每秒被中断的次数

​	cs(context switch)：进程切换的速率



**cpu**：显示关于CPU的使用情况(以下的百分比指的都是占用CPU时间的百分比)

​	us(user space)：用户运行程序占用CPU的百分比

​	sy(system,kernel)：用于运行内核占用CPU的百分比

​	id(idle)：空闲CPU百分比

​	wa(wait io)：等待I/O花费的百分比

​	st(stolen)：被虚拟机"偷走"的百分比



## 3.8  pmap

**作用**：显示一个进程的内存映射表

**使用方法**

```bash
pmap [options] pid [...]

options：
	-x：显示详细格式的信息
```



pmap是读取`/proc/PID/maps`下的文件得到信息的。可以直接使用`cat /proc/PID/maps`命令来获取pmap输出的信息(PID用想要查看的进程号取代)



## 3.9  glances

> 安装此软件需要EPEL源

**作用**：glances是跨平台的监控工具，以窗口化的方式显示信息。能够监控CPU、负载、内存、磁盘IO、网络流量、文件系统、系统温度等信息。

> 企业中，远程监控一般都使用专门的监控系统而不是glances；但对于没有部署监控系统而需要收集远程数据的情况下，就可以使用到glances了。

**使用方法**：注意以下提供的参数都是1.x.x版本的，2.x.x版本的glances选项意义有些不同	

```bash
glances [OPTIONS]

OPTIONS:
	-d：关闭磁盘IO功能模块
	-b：以Byte/s为单位显示网卡设备数据交换速率
	-o {HTML|CSV}：将glances输出成HTML和CSV文件，之后就可以用网页或以CSV的形式查看glances的内容
	-f FILEPATH：设置-o参数输出文件的位置
	-m：关闭mount功能模块
	-n：关闭网络功能模块
	-r：关闭进程列表功能模块
	-t SECS：指定延迟时长为SECS,默认为3秒
	-1：数字1，单独显示每颗CPU相关负载数据信息
	
glances打开的窗口也可以使用内置命令，按回车键可以进行筛选进程。按h键可以查看可用的所有命令,有需要可以自己查询。
```

> 2.x.x版本的输出成CSV文件的参数：--export-csv EXPORT_CSV
>
> glances工具可以输出文件的功能可以方便以后对报告进行分析和绘制成图形。

glances可以为Unix和Linux性能专家提供监视和分析性能数据的功能，其中包括：

1. CPU使用率
2. 内存使用情况
3. 内核统计信息和运行队列信息
4. 磁盘IO速度，传输和读/写比率
5. 文件系统中的可用空间
6. 磁盘适配器
7. 网络IO速度，传输和读/写比率
8. 页面空间和页面速度
9. 消耗资源最多的进程
10. 计算机信息和系统资源



glances还支持C/S模型的远程模式，接下来就介绍下远程模式的使用方法：

```bash
Server：服务器开启监听
	开启方法： glances -s -B IPADDR
		-B：后跟本地监听的地址
Client：以远程模式启动glances，远程连接到指定的服务器，监控Server上的数据
	连接方法：glances -c IPADDR
		-c：后跟远程连接的服务器地址
```



**字段意义**

下图是glances命令执行后，打开的窗口

![1554874368449](../归档/images/1554874368449.png)



上图中的大部分内容都和top和htop差不多。因此仅仅介绍红色框框中的字段。

**IOR/s**:进程的读速率

**IOW/s**：进程的写速率

**左侧显示的内容为**：带宽下载上传速度，磁盘IO速度，分区使用的情况，传感器检测到的温度(这里没有显示，因为我运行的是虚拟机)



## 3.10  dstat

> 该命令需要光盘源安装

**作用**：dstat包含了vmstat、iostat、netstat和ifstat这些产品的功能，不仅如此，dstat还额外添加了一些新的功能和监控项。dstat可以很方便地监控系统运行状况并用于基准测试和排除故障。



**dstat的特性**：

1. 结合了vmstat、iostat、ifstat、netstat以及更多的信息
2. 实时显示统计情况
3. 在分析和排障时可以通过启用监控项并排序
4. 模块化设计
5. 使用python编写的，更方便扩展现有的工作任务
6. 容易扩展和添加你的计数器
7. 包含的许多扩展插件充分说明了增加新的监控项目是很方便的
8. 可以分组统计块设备/网络设备，并给出总数
9. 可以显示每台设备的当前状态
10. 极精确的时间精度，即便是系统负荷较高也不会延迟显示
11. 显示准确地单位和限制转换误差范围
12. 用不同的颜色显示不同的单位
13. 显示中间结果延时小于1秒
14. 支持输出CSV格式报表，并能导入到Gnumeric和Excel生成图形



**使用方法**：

```bash
dstat [-afv] [options..] [delay [count]]

delay：延迟
count：刷新的次数(显示出的行数为count+1)

options：
	-a：相当于-cdngy，是默认的选项
	-c：显示cpu性能指标的速率数据
	-d：显示disk相关的速率数据
	-g：显示page相关的速率数据
	-i：显示interrupt相关的速率数据
	-f：显示扩展的统计数据
	-l：显示load average相关的统计数据
	-m：显示memory相关的统计数据
	-n：显示网络接口的收发数据速率
	-p：显示进程相关的统计数据
	-r：io请求的速率
	-s：显示swap的相关数据
	-y：显示系统相关的数据，包括中断和进程切换
	
	--top-cpu：显示最占用CPU的进程
	--top-bio：显示最消耗block io的进程
	--top-io：显示最占用io的进程
	--top-mem：显示最占用内存的进程
	--ipc：显示进程间通信相关的速率数据
	--raw：显示raw套接的相关的数据
	--tcp：显示tcp套接字的相关数据
	--udp：显示udp套接字的相关数据
	--unix：显示unix sock接口相关的统计数据
	--scoket：显示所有套接字的统计数据
```

> 以上内容都不要强行记住，有需要man一下即可。



**dstat常用的命令参数组合**

查看最占用内存的进程信息

```bash
dstat -g -l -m -s --top-mem
```

![1554879021629](../归档/images/1554879021629.png)



查看最消耗CPU的进程信息

```bash
dstat -c -y -l --proc-count --top-cpu
```

![1554879098816](../归档/images/1554879098816.png)





**dstat显示的字段意义**：

dstat显示的结果为下图

![1554878507141](../归档/images/1554878507141.png)

接下来给出红框中字段的意义：

**paging**：这是系统的分页活动，分页是一种内存管理技术用于查找系统系统场景，一个较大的分页表明系统正在使用大量的交换空间，或者说内存非常分散。大多数情况下，系统管理员都希望看page in(换入)和page out(换出)的值是0和0。

**system**：这一项显示的是中断(int)和上下文切换(csw)。这项统计仅在有比较基线时才有意义。这一栏中较高的统计值通常表示大量的进程造成堵塞，需要对CPU进行关注。服务器一般情况下都会运行一些程序，所以这项总是显示一些数值。



## 3.11  kill和killall

**kill的作用**：发送指定信号给进程

**killall使用方式**：

```bash
kill -l [signal]
查询当前系统可用的信号；signal指定为数字则回显对应的信号简写名称，signal指定为简写名称则回显对应的数字。

kill [-SIGNAL] PROGRAM

常用的SIGNAL：
	SIGHUP：1,让进程重新读取配置文件以让新的配置生效，而无需重新启动进程
	SIGINT：2，打断正在运行中的进程，相当于发送组合键Ctrl+c
	SIGKILL：9，强行中止正在运行中的进程，一般用来kill僵尸进程
	SIGTERM：15，安全中止正在运行的进程，这是默认的SIGNAL
	SIGSTOP：19，暂停指定的进程
	SIGCONT：18，继续运行指定的暂停进程
```



**killall的作用**:根据名称关闭进程，也可以一次性关闭一个服务的所有进程。

**kiall的使用方法**：

```bash
killall [options] [-SIGNAL] PROGRAM

options:
	-i：交互式的关闭进程
	-I：查询时忽略大小写
```



## 3.12  nice和renice

前面在1.5和1.6小节我们介绍过进程优先级和nice值的概念，想要修改静态优先级就需要使用接下来介绍的两个命令。

**nice的作用**：在程序运行前修改该程序的nice值，若不修改默认的nice值为0。

**nice的使用方法**

```bash
nice -n N COMMAND
N为nice值，范围是-20~19
```



**renice的作用**：修改已启动并处于运行中的进程的nice值

**renice的使用方法**：

```bash
renice -n N PID
```



> 可以使用ps -eFl | grep PROGRAM显示PROGRAM的nice值

# 4.  作业的概念



## 4.1  什么是作业？

作业（job）是计算机操作者（或是一个叫做作业调度器的程序）交给操作系统的执行单位。作业可以是一次应用程序的运行，也可以是多个相关进程一起运行的过程。通常作业都是以批处理(非交互式)的模式运行的。



## 4.2  作业的分类

作业可以分为前台作业和后台作业：

**前台作业**：通过终端启动，并且在停止前会一直占据终端

**后台作业**：作业的启动与终端无关；或者也可以是通过终端启动，但启动后立即转入后台运行



## 4.3  如何让作业运行在后台？

1. 对于已经启动且占据终端的作业，可以使用`ctrl+z`快捷键将其送往后台。需要注意的是：使用该快捷键送往后台的作业会处于停止态。
2. 对于尚未启动的作业可以使用`COMMAND&`命令，将要运行的作业送往后台。

**注意**：以上两种方法处理后的作业仍然与终端相关，作业会随着对应终端的关闭而关闭。若要使作业变为脱离终端的后台作业则可以使用`nohup COMMAND&`



# 5.  作业的查看及管理命令



## 5.1  jobs

**作用**：可以列出当前后台运行的作业,使bash的内置命令

**使用方法**：

```bash
jobs [options]

options:
	-l：可以显示该作业包含的所有进程的进程号
	-p：仅显示所有作业的进程号
	-r：筛选出处于running状态的作业
	-s：筛选出处于stopped状态的作业
	-n：显示上次调用jobs后有更新的信息
```



使用jobs查看作业时，作业前带`+`的作业是下次fg,bg自动(不带参数时)选择的作业，例如下图的作业\[2\]。

![1554884099628](../归档/images/1554884099628.png)



## 5.2  fg

**作用**：将后台的作业调回前台

**使用方法**

```bash
fg [job_spec]

若不指定作业号，则默认调用jobs回显出的带+号的作业
```



## 5.3  bg

**作用**：把调往后台的作业启动起来，让其在后台运行(前提是该作业必须支持运行于后台)

**使用方法**：

```bash
bg [job_spec]

若不指定作业号，则默认调用jobs回显出的带+号的作业
```



## 5.4  kill

**作用**：上面3.11小节介绍的kill不仅可以关闭进程，也可以关闭作业

**使用方法**：

```bash
kill %job_num
```







------

- 进程管理的工具还有很多，这里再列出几个有名的进程管理工具：sar,tsar,iostat,iftop,nethog；若有兴趣则可以自己查阅资料。
- 上面的很多内容参考了马哥Linux的参考笔记。

- 本博客借用了不少他人的内容，若有侵权，敬请告知。邮箱：445701902@qq.com

点击[此处](#des)跳转至文章开头

