# 1.  学习Openssl的基础

首先要知道的是，我们在互联网上传输的数据是可以被随便窃听的。因此我们会采用加密技术来使得数据即使被窃取，若被窃取的人手中没有解开加密的密钥就无法获取信息的内容。

> 若上面一段的内容读者都无法理解的话，我在这里推荐一部电影：《模仿游戏》。这部电影演绎了图灵为破解纳粹密码而发明计算机的过程。

**加密算法**：加密算法并不仅仅指的是将数据加密的过程，其包含了数据从发送端是如何加密以及接收端是如何解密两个过程。

**密钥**：建立在加密算法之上的，发送方和接收方的密钥匹配才能正常的加解密数据。

接下来举一个比较简单的例子来表示如何加密解密，例如：当你要发送的数据为3时，首先将其加5乘4，然后接收方接收到数据后，需要将其除4减5得到原始数据。以上的例子中，我们可以认为加上某个数再乘上某个数是一个加密算法，而5和4就是一个密钥，加密解密的时候如果不匹配则无法解开数据。

> 当然上面举得例子只是为了更好的向大家解释加密算法和密钥是什么。事实上也根本没有上面所说的这种加密算法，因为这种加密算法实在是弱爆了，加密的密钥是很容易直接被算出来的。现代的加密算法是相当的复杂的，连计算机都无法轻易破解。



实现网络通信安全的目标：

- **保密性**：confidentiality，确保通信内容不被第三方看懂
- **完整性**：integrity，保证数据在传输过程中是完整的，
- **可用性**：availability，另外还能够保证在传输给接收方后，接收方能够还原回原来的数据，并且还原后的数据还能使用



攻击类型及其常见方法：

- 威胁保密性的攻击：窃听、通信量分析；
- 威胁完整性的攻击：更改、伪装、重放、否认
- 威胁可用性的攻击：拒绝服务（DoS），分布式拒绝服务(DDoS)



学习ssl的基础就是学习各种加密类型的特点及缺陷。

首先先列出四种加密类型：

1. 对称加密
2. 非对称加密
3. 单向加密
4. 密钥交换

接下来我会详细讲解各种加密类型的特点和缺陷，并列出各类型对应的常见加密算法。





## 1.1  对称加密

对称加密**概述**：加密和解密使用同一个密钥，其实现依赖于算法和密钥，但其安全性只依赖于密钥而不依赖于算法，若密钥被窃取则可直接导致加密的数据泄露。

对称加密的**特性**：

1. **加密、解密使用同一个密钥**
2. **将明文分隔成固定大小的块，逐个进行解密**

对称加密的**缺陷**：

1. **密钥过多**；例如：服务器端需要和成千上万的客户端进行通信，针对每个客户端都需要保存一个特别的密钥
2. **密钥分发困难**；客户端和服务端之间密钥分发也需要加密，否则会导致密钥本身泄露



对称加密的**常见算法**：

**DES**：Data Encryption Standard，短密钥长度为56位，从一开始就受到批评，对于大多数当前的应用来说它太不安全，但它在现代密码学的发展中具有很大的影响力。

**3DES**

**AES**：Advanced Encryption Standard，成为高级加密标准。在密码学中又称**Rijndael加密法**，是[美国联邦政府]采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。**支持的密钥长度**：128，192，256，384，512（单位为bit）。

**Blowfish**

**Twofish**

**IDEA**

**RC6**

**CAST5**





## 1.2  非对称加密

非对称加密**概述**：非对称加密有两个加密密钥，一个是公钥，一个是私钥，两者统称为密钥对。

**公钥**：是公开给所有人使用的

**私钥**：仅允许个人使用。

**公钥与私钥的关系**：公钥是从私钥中提取得来的，使用公钥加密的数据，只能使用与此公钥配对的私钥解密。

**如何加密？**

加密时既可以使用公钥也可以使用私钥，若发送端使用公钥加密则接收端只能用对应的私钥解密，若发送端使用私钥加密则接收端只能用对应的公钥解密，但使用公钥加密和使用私钥加密所起到的作用是不一样的，后面内容会详细讲解。



非对称加密的**用处**：

1. **身份认证**：主要用于让接收方确认发送方的身份。其实现方式是：私钥拥有者用自己的私钥加密的数据，所以只要可以用其公钥解密，就可以认证其身份。这也就是上面所说的公钥加密的作用。
2. **密钥交换**：发送方先获取对方的公钥，然后发送方用对方的公钥加密一个对称密钥，再发送给对方。由于私钥只有接收方才会拥有，所以可以保证加密后的对称密钥不会泄露。
3. **数据加密**：非对称加密（必须是公钥加密，私钥加密）的安全性高，但是性能太差，比对称加密要慢三个数量级($$10^3$$倍)，因此这项功能几乎不用。



非对称加密的**特性**：

1. 密钥长度较大，例如512bits，2048bits，4096bits
2. 加密和解密分别使用密钥对中的密钥相对进行
3. 常用于数据签名和密钥交换

> 上面特性中的1和2点恰好印证了非对称加密的特性------安全性高但性能太差。



常见的加密算法：

**RSA**

**DSA**

**ELGamal**





## 1.3  单向加密

单向加密**概述**：即提出数据指纹。该类加密算法只能加密不能解密，是用来做数据校验的，也就是验证数据在发送过来的途中有没有被篡改过。

**单向加密及其解密过程**：发送方发送数据前，进行单向加密产生数据指纹，然后将这个数据指纹附着于原有的数据后面，然后将数据和特征码一起发送给接收方；接收方接收到这个数据后，会用同样的单向加密算法对接收到的原有数据（不包括发送来的特征码）进行加密得到特征码，然后接收方会将自己计算出的特征码与发送而来的特征码作比对，若两者一样说明数据没有被篡改过。



单向加密的**特性**：

1. **定长输出**：无论原来的数据是多大级别，其加密结果长度一样。
2. **雪崩效应**：原始数据的微小改变会导致结果的巨大变化
3. **不可逆**



单向加密的**用处**：

1. **验证数据完整性**：即数据在发送而来的途中有没有被篡改过
2. **系统账号密码校验**：以Linux中的验证机制为例，用户登录时输入的密码通过单向加密后提取出特征码，让其与/etc/shadow文件中的内容做比对，若两者一致，则验证通过，用户登录。





## 1.4  密钥交换

密钥交换**概述**：IKE(Internet Key Exchange)；双方通过交换密钥来实现数据加密解密；密钥交换有以下两种；

**公钥加密**：将公钥加密后通过网路传输到对方进行解密，这种方式还是有很大的可能被截取破解，因此并不常用。

**DH**(Deffic-Hellman)：双方共有一些参数，共同协商加密算法，除此之外双方还有属于自己的私有参数，通过共有的参数、私有参数和算法信息来进行加密，然后双方将计算后的结果进行交换，交换完成后再和属于自己私有的参数进行特殊算法，经过双方计算后的结果是相同的，而这个结果就是密钥。

下面以一个例子讲解DH的大概：

首先命名发送端为A以及接收端为B。

A有p和g两个参数，A还有一个属于自己的私有参数x；

B有p和g两个参数，B还有一个属于自己的私有参数y；

A和B有相同的加密算法即：

A：P^X%G

B：P^Y%G

然后将上面的内容进行交换，此时

A拿到B的P\^Y%G，B拿到A的P\^X%G，双方再和自己私有参数进行相同的算法，即：

​	A：对P\^Y%G再求X次方得到(P\^Y%G)\^X=P\^XY%G

​	B：对P\^X%G再求Y次方得到(P\^X%G)\^Y=P\^XY%G

最后生成的结果就是密钥，对于双方而言是一样的。

注意：整个过程对于第三方人员只能获取p、g两个值，AB双方交换的是经过计算后的值，因此这种加密方式是很安全的。



**其他的密钥交换算法**：ECDH（椭圆曲线DH），ECDHE（临时椭圆曲线DH）





# 2.  通信加密的具体过程

其实一次加密的通信会用到上面的多种加密算法。

一次通信加密过程中，发送者和接收方的行为如下：

**发送者的行为**：

1. 使用单向加密算法提取生成数据的特征码
2. 使用自己的私钥加密特征码附加在数据后面
3. 生成用于对称加密的临时密钥
4. 用此临时密钥加密数据和已经使用私钥加密后的特征码（该步用来实现数据保密性）
5. 使用接收方的公钥加密此临时密钥，附加在对称加密后的数据后方（该步用来实现数据保密性）



**接收方的行为**：

1. 使用自己的私钥解密加密的临时密钥；从而获取对称密钥。
2. 使用对称密钥解密对称加密的数据和私钥加密的特征码密文；从而获得数据和特征码密文
3. 使用发送方的公钥解密特征码密文，从而获得从计算生成的特征码（该步用来身份认证）
4. 使用与对方同样的单向加密算法计算数据的特征码，并与解密而来的进行比较（该步用来验证数据完整性）



发送者和接收方的行为互为逆过程。



虽然上面所讲的通信加密过程用了多种加密算法，看着像是很安全的过程，但其实不然。在这里我们需要知道一种叫做**中间人攻击**的手法：中间人是一个攻击者，它在通信双方交换公钥前，更早的将自己的公钥发送给双方并欺骗双方自己就是其通信对端。而上面的通信加密过程就无法避免中间人攻击。

光用概念讲解中间人攻击是不太好理解的，这里我们用一个例子来讲解中间人攻击的具体过程：

![1556585772859](images/1556585772859.png)

接下来会以上图来讲解中间人攻击：

图中的Bob和Jhon是通信双方，Hacker是攻击方

若Jhon和Bob没有进行通信过，则Eve可以欺骗Jhon说：我是Bob，并将其的公钥发送给Jhon，然后Jhon发送给Bob的信息都可以被Eve自己的私钥解密。并且Eve用同样的手法欺骗Bob；然后Eve就可以得到Jhon和Bob交流的信息。

因此避免中间人攻击的问题就变成了如何可靠的取得对方公钥的问题。

由上，引出接下来的CA机制，CA机制正是为了解决可靠取得对方公钥而设计的。





# 3.  CA

CA**概述**：CA是用来保证通信双方可靠地获得对方公钥而设立的第三方机构。

**数字证书概念**：数字证书是通过防伪技术的公钥，是由第三方机构CA颁发的。

CA的运行机制用概念也很难说清，因此接下来用一张图来解释之：

![1556585467530](images/1556585467530.png)

图中Bob和Jhon是通信双方，CA就是颁发数字证书的服务器。

Bob注册数字证书时，会将公钥发送给CA，让CA对公钥做防伪技术，然后将做好防伪技术的公钥发送回给发送公钥方。此后，若Bob要和Jhon做通信，Bob则会将做好防伪技术的公钥发送给Jhon。而Jhon接收到证书后，不会立即认同这个证书是安全的，Jhon需要确认证书中的内容是合法的，也是其所信任的CA颁发的①，若这两点都验证正确，则可以信任证书来源就是真的Jhon。

> ①：我们要知道的是：CA仅仅只是一个服务器，我们自己也可以搭建一个CA服务器，因此中间人（Hacker）也可以自己去创建一个私有的CA去以Bob或Jhon的身份去办一个数字证书，但这并不能欺骗Jhon和Bob，因为他们只信任自己所认同的CA。（类似于现实生活中的办证，你去办的证书看着是真的，但别人一上网一查学信网，你是否作假别人一眼就看出了）



**因此如何验证CA是不是合法的CA？**

CA会用自己的私钥去加密整个证书的特征码（特征码也是单向加密得到的），接收证书方用CA的公钥解密。能解密则证明证书是CA发的，并用单向加密算法计算特征码，将其与解密出来的比较是否一样，若一样则没有问题。



**CA的主从关系**：CA有主从关系，全球有一个根CA，在根下有从CA，CA之间的信任关系可以传递，全球的CA数量是有限的。



某些注明的操作系统会将CA签发的证书直接安装在系统上，所以不需要通过获取CA了。当比对证书时，若操作系统中没有固化这些证书，则可以说该证书是不合法的。



CA的证书是自己给自己发的，被称为**自签名证书**。



# 4.  PKI

CA只是PKI（Public Key Infrastructure，公钥基础设施）的一个组成部分，其中PKI包括了：

**签证机构**：CA，是真正颁发证件的机构（可以理解为我们办理身份证时的公安局）

**注册机构**：RA，帮你信息录入的机构（可以理解为我们办理身份证时的派出所）

**证书吊销列表**：CRL，若某个主机丢失了自己的私钥，则会向CA申请将其的证书吊销，CA会将其加入其的证书吊销列表，以方便接收到证书的一端校验。如果某个证书被吊销了，则这个证书就不会被其他的主机所信任了。

**证书存取库**：顾名思义，就是存取数字证书的库



# 5.  数字证书格式

数字证书由一下几个部分组成：

**版本号**（version）；

**序列号**（serial number）：CA用于唯一标识此证书的号码

**签名算法标志**（Signature algorithm identifier）；

**发行者的名称**：即CA自己的名称

**有效期**：两个日期，起始日期和终止日期

**证书主体名称**：证书拥有者自己的名称

**证书主体公钥信息**：证书拥有者自己的公钥

**发行商的唯一标识**；

**证书主体的唯一标识**;

**扩展信息**；

**签名**：CA对此证书的数字签名



## 5.1  证书示例

我们可以使用浏览器查看一个使用https协议的网站所用的证书，例如接下来我用谷歌浏览器查看百度的数字证书：

![1556673676723](images/1556673676723.png)

先点击锁，然后点击证书，然后就会弹出证书的相关信息。

![1556673788951](images/1556673788951.png)

![1556673839542](images/1556673839542.png)



# 6.  SSL和TLS

接下来讲解两种数字证书------SSL和TLS

**SSL**（Secure Socket Layer，安全套接字层）：是为网络通信提供安全及数据完整性的一种安全协议。处于应用层和传输层之间，这层可有可无，若调用值，则可以实现安全的通信；若不调用之，则无法保证安全，但还是可以继续通信。

由Netscape公司在1994年提出

SSL的**版本**：V1.0（从来没有发布过）, V2.0（发布过，但后来发现有漏洞被V3.0取代）, V3.0（据谷歌说有漏洞）



**TLS**（SSL的继承版本）：Transport Layer Security，为了避免SSL垄断而研发的，二者都是兼容的。

由IETF在1999年发布的                

V1.0, V1.1, V1.2, V1.3（1.3版本支持椭圆曲线加密算法，据说是很安全的加密算法）

目前推荐使用TLSV1.3版本

 

**TLS采用了分层设计**：

1. 最底层：基础算法原语的实现，aes, rsa, md5
2. 向上一层：各种算法的实现； 
3. 再向上一层：组合算法实现的半成品；
4. 用各种组件拼装而成的各种成品密码学协议软件；

TLS可以实现仅调用某几层。



**有很多之前的协议无法支持通信加密，因此会在应用层和传输层之间调用TLS和SSL来达到通信加密的目的**。**例如**：http--> ssl/tls --> https，即http调用了ssl或tls后就会变成https。



## 6.1  SSL会话具体过程

SSL会话的具体过程可以参考下图：

![由Essich - eigene Arbeit, based on a PNG-image by Christian Friedrich, using Cliparts from openclipart.org (koliberek)，CC BY 3.0，https://commons.wikimedia.org/w/index.php?curid=9031795](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg/1024px-SSL_handshake_with_two_way_authentication_with_certificates.svg.png)

参考上图，以下详细讲解基于SSL的通信是怎么实现的？

1. 双方事先要建立SSL会话。客户端发送hello信息给服务器端，服务器端响应hello信息给客户端。即双方决定好用SSL会话了。
2. 双方需要协商接下来使用什么加密算法（例如接下来的单向加密算法用什么？对称加密算法用什么）
3. 客户端请求服务器端的证书，服务器端将自己的证书发送给客户端
4. 客户端验证证书是否有问题
5. 服务端请求客户端发送证书，客户端将自己的证书发送给服务端（这一步不一定存在，一般存在于网上银行转钱的过程）
6. 客户端证书验证完成（以及服务端验证证书完成后），客户端选择一个随机数当做对称加密的密码，将该密码用服务端的公钥加密后发送给服务端，服务器端通过解密，单向加密得到对称加密的密钥，将客户端请求的网页用该密钥加密后发送给客户端。然后客户端就可以浏览到对应的网页了。
7. 接着断开会话，客户端请求服务端断开会话。
8. 服务端确认断开



------

这篇博客是一名入门运维的新手所写，其实并没有过多的工作经验，有很多生产环境中需要注意的地方我有可能并没有写全甚至没有写对，但请大家多多包涵，提出错误之处，我好认真修改，提前谢谢了。

**联系方式**：445701902@qq.com