# 1、100.0.0.16/28 对应网段的网关地址、广播地址、可分配IP地址范围

做这种题目第一步需要将IP地址和掩码扩展成二进制，扩展结果如下：

```
IP地址:  01100100.00000000.00000000.00010000
子网掩码：11111111.11111111.11111111.11110000
```

<<<<<<< HEAD
然后将IP地址对应的子网掩码为1的部分保留，得到**网络号**：
=======
然后将IP地址与子网掩码做**与**运算得到**网络号**：
>>>>>>> 2c0929cb7029386ee7c583b3238fe42a2b699004

```
网络号二进制:  01100100.00000000.00000000.00010000
转换成十进制为：100.0.0.16
```

**网络号**为100.0.0.16



**网关地址**是在可分配IP地址范围中任意的一个，并不是固定的。



**广播地址**需要将子网掩码取反，然后与网络号相加：

```
子网掩码取反：00000000.000000000.00000000.00001111
与网络号相加结果：01100100.00000000.00000000.00011111
转换为十进制为：100.0.0.31
```

**广播地址**为100.0.0.31

可分配IP地址即广播地址和网络号之间的地址：

**可分配IP地址**为100.0.0.17\~100.0.0.30



综上所述该题的解为：

```
网络号：100.0.0.16
网关地址：100.0.0.17~100.0.0.30中的任意一个
广播地址：100.0.0.31
可分配IP地址：100.0.0.17~100.0.0.30
```



# 2、tcpdump的使用方法

**功能介绍**：转储本机的某个网络接口(可以理解为网卡)的流量包。类似于wireshark，也可以通过指定协议、网络层、主机等来筛选出想要的信息。



其中，筛选出的每个流量包都会输出对应的一行信息，例如下面的一行信息，以下面的一行信息为例讲解一下信息输出的格式：
```shell
①09:57:04.086752 ②IP gateway.56436 > ③localhost.localdomain.ssh: ④Flags [.], ⑤ack 148, ⑥win 2049, ⑦length 0
```
**信息输出的格式**：①时间戳 ②网络层类型 ③流量包的源地址和端口 ④流量包的目的地址和端口 ⑤Flags ⑥ack  ⑦win ⑧length(在Flags和ack中间还可能会有seq字段)

> 若要详细理解⑤~⑧的内容则需要学习tcp/ip协议栈中的知识，原谅博主能力有限，这里给不出详细的解释。



**使用方法**：

```shell
tcpdump [OPTIONS] [expression]


常用的OPTIONS:
	-D：列出当前可用的网络接口
	-F FILE：将文件的内容当做expression
	-i INTERFACE：指定网络端口
	-c COUNT：指定收到多少个流量包后退出；若不指定-c，则需要使用"Ctrl+C"快捷键来退出转储过程
	-w /PATH/TO/FILE：将输出的信息保存到某个文件，以便以后分析
	-r /PATH/TO/FILE：将用-w选项保存的信息读出（若直接使用cat将其读取会读到二进制信息）
	-A：以ASCII码显示输出的信息；该功能使得捕获网页来说比较方便
	-C FILE_SIZE：将信息写入文件时，指定文件的最大大小，单位为MB(1,000,000bytes)。若大于，则会关闭当前文件，打开一个新的文件开始记录。第一个保存文件使用-w指定的名称，后续的将在名称后加入数字，该数字从1开始继续向上
	-e：将数据链路层的信息也打印出来
	-n：输出时，不要将IP地址转换为主机名
	-q：将输出的信息简化
	-I：监控模式。若想要边使用-w保存，边读保存的信息，则需要使用这个选项，但不是所有的系统和设备都支持这个这种模式。
	
expression：用来筛选信息的表达式，可以指定协议、网络层、主机等等
常见的expression有：
	host IPADDR|HOSTNAME：筛选出发往host或从host发来的流量包
		例如：tcpdump host 192.168.10.30
	port PORT_NUMBER|PROTOCOL：筛选出发往指定端口或从指定端口发来的流量包
		例如: tcpdump port ssh
			  tcpdump port 22
	dst|src ...：不会单独使用，需要配合其他expression来达到进一步筛选的目的。
		例如：tcpdump dst port ssh		# 将目的协议是ssh的筛选出来
	less PACKET_LENGTH：筛选出包长度小于PACKET_LENGTH的流量包
		例如：tcpdump less 1000
	greater PACKET_LENGTH：筛选出包长度大于PACKET_LENGTH的流量包
		例如：tcpdump greater 1000
	tcp：筛选出tcp包
		例如：tcpdump tcp
	udp：筛选出udp包
		例如：tcpdump udp
	icmp：筛选出icmp包
		例如：tcpdump icmp
```



**示例**：

1、列出当前可用的网络接口

```
~]# tcpdump -D
```

2、显示ens33接下来会收到的4个流量包

```
~]# tcpdump -i ens33 -c 4
```

3、将ens33接下来会收到的1000个流量包信息保存至 /tmp/tcpdumptest 中，并可以在保存中边保存边查看（前提是你的设备和系统支持监控模式）。

```
~]# tcpdump -l > /tmp/tcpdumptest &tail -f /tmp/tcpdumptest
```



# 3、详细叙述僵尸进程产生的原因以及危害

**僵尸进程产生的原因**：子进程比父进程先结束，而父进程又没有回收子进程，释放子进程所占用的资源，此时子进程就会成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源。

**僵尸进程的危害**：**1**、僵尸进程占用的资源没有被回收，就会造成资源的浪费。**2**、每一个进程都会占用一个进程号，而系统中可用的进程号是有限的，若系统中有大量的僵尸进程则会出现没有可用的进程号而不能产生新的进程的情况。



# 4、 vmstat的使用方法

> 应聘Linux运维岗位的同学需要认真的记住该命令的字段含义，据说面试经常考这个命令

**作用**：统计虚拟内存的统计数据。也可以动态显示内存、磁盘、网络、cpu等资源的使用情况。

**使用方法**：

```bash
vmstat [options] [delay [count]]

delay：指定刷新的间隔
count：指定刷新的次数

options:
	-s：显示内存统计数据
	-S：衔接单位，如K、M、b，默认单位为k
	-d：列出各个磁盘的读写总量统计表
```



下面给出vmstat的输出：

![1554864771404](images/1554864771404.png)

参考上图，以下列出各个字段的意义

**procs**：表示与进程相关的信息

​	r：等待在CPU上运行的任务的队列长度，即等待运行的进程的个数

​	b：处于不可中断睡眠状态的进程个数，即IO阻塞队列长度



**memory**：与内存相关的信息

​	swpd：交换内存的使用量

​	free：空闲的物理内存量

​	buffer：用于buffer的内存总量

​	cache：用于cache的内存总量



**swap**：与交换分区相关的信息

​	si：数据进入swap中的速率(kb/s)

​	so：数据离开swap的速率(kb/s)



**io**：与io相关的信息

​	bi：将块设备的数据读入到系统的速率(kb/s)

​	bo：将数据保存至块设备的速率(kb/s)



**system**：显示有关于系统的信息

​	in：中断速率，每秒被中断的次数

​	cs(context switch)：进程切换的速率



**cpu**：显示关于CPU的使用情况(以下的百分比指的都是占用CPU时间的百分比)

​	us(user space)：用户运行程序占用CPU的百分比

​	sy(system,kernel)：用于运行内核占用CPU的百分比

​	id(idle)：空闲CPU百分比

​	wa(wait io)：等待I/O花费的百分比

​	st(stolen)：被虚拟机"偷走"的百分比





------

tcpdump的内容略有参考这篇博客：https://blog.51cto.com/vinsent/1983295，这篇博客写的非常不错，可以学习一下。
